[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "code/analysis.html",
    "href": "code/analysis.html",
    "title": "Scraping datos de canciones y letras + EDA",
    "section": "",
    "text": "import os\nfrom dotenv import load_dotenv\nimport subprocess\nimport pandas as pd\nimport time\nimport spotipy\nfrom spotipy.oauth2 import SpotifyClientCredentials\nimport requests\nfrom bs4 import BeautifulSoup\nimport unidecode\nimport re\nfrom typing import Optional\n\n\n\n\n\n# Cargar las variables de entorno desde el archivo .env\nresult = load_dotenv()\n\n\n\n\n\n# Función para inicializar el cliente de Spotify\ndef initialize_spotify_client(client_id: str, client_secret: str) -&gt; spotipy.Spotify:\n    auth_manager = SpotifyClientCredentials(\n        client_id=client_id, client_secret=client_secret\n    )\n    return spotipy.Spotify(auth_manager=auth_manager)\n\n\n# Función para obtener todos los álbumes de un artista\ndef get_albums(sp: spotipy.Spotify, artist_name: str) -&gt; list[dict[str, any]]:\n    results = sp.search(q=artist_name, type=\"artist\", limit=1)\n    artist_id = results[\"artists\"][\"items\"][0][\"id\"]\n\n    albums = []\n    results = sp.artist_albums(artist_id, limit=50, album_type=\"album\")\n    albums.extend(results[\"items\"])\n\n    while results[\"next\"]:\n        results = sp.next(results)\n        albums.extend(results[\"items\"])\n\n    return albums\n\n\n# Función para obtener las canciones de un álbum\ndef get_tracks_from_album(sp: spotipy.Spotify, album_id: str) -&gt; list[dict[str, any]]:\n    tracks = []\n    results = sp.album_tracks(album_id)\n    tracks.extend(results[\"items\"])\n\n    while results[\"next\"]:\n        results = sp.next(results)\n        tracks.extend(results[\"items\"])\n\n    return tracks\n\n\n# Función para obtener las características de audio de las canciones\ndef get_audio_features(\n    sp: spotipy.Spotify, track_ids: list[str]\n) -&gt; list[dict[str, any]]:\n    return sp.audio_features(track_ids)\n\n\n# Función principal para extraer información de un artista\ndef fetch_artist_data(\n    sp: spotipy.Spotify, artist_name: str, output_file: str, pause_time: float = 1.0\n) -&gt; list:\n    albums = get_albums(sp, artist_name)\n\n    song_data = []\n\n    for album in albums:\n        album_name = album[\"name\"]\n        album_id = album[\"id\"]\n        album_release_date = album[\"release_date\"]\n        album_type = album[\"album_type\"]\n\n        tracks = get_tracks_from_album(sp, album_id)\n\n        for track in tracks:\n            track_id = track[\"id\"]\n            track_name = track[\"name\"]\n            track_duration_ms = track[\"duration_ms\"]\n\n            audio_features = get_audio_features(sp, [track_id])[0]\n\n            song_data.append(\n                {\n                    \"album_name\": album_name,\n                    \"album_id\": album_id,\n                    \"album_release_date\": album_release_date,\n                    \"album_type\": album_type,\n                    \"track_name\": track_name,\n                    \"track_id\": track_id,\n                    \"track_duration_ms\": track_duration_ms,\n                    \"track_tempo\": audio_features[\"tempo\"],\n                    \"track_key\": audio_features[\"key\"],\n                    \"track_mode\": audio_features[\"mode\"],\n                    \"track_danceability\": audio_features[\"danceability\"],\n                    \"track_energy\": audio_features[\"energy\"],\n                    \"track_loudness\": audio_features[\"loudness\"],\n                    \"track_speechiness\": audio_features[\"speechiness\"],\n                    \"track_acousticness\": audio_features[\"acousticness\"],\n                    \"track_instrumentalness\": audio_features[\"instrumentalness\"],\n                    \"track_liveness\": audio_features[\"liveness\"],\n                    \"track_valence\": audio_features[\"valence\"],\n                    \"track_time_signature\": audio_features[\"time_signature\"],\n                }\n            )\n\n        # Pausar para evitar el límite de la API\n        time.sleep(pause_time)\n\n    # Guardar los datos en un archivo CSV\n    df = pd.DataFrame(song_data)\n    df.to_csv(output_file, sep=\"\\t\", index=False)\n\n\n\n\n\n# Función para obtener la letra de la canción de Lyrics On Demand\ndef get_lyrics_from_lyricsondemand(\n    artist: str, song_title: str, base_url: str = \"https://lyricsondemand.com\"\n) -&gt; Optional[str]:\n    # Normalizar nombres eliminando acentos y espacios\n    artist = unidecode.unidecode(artist.lower()).replace(\" \", \"\") + \"lyrics\"\n    song_title = unidecode.unidecode(song_title.lower()).replace(\" \", \"\") + \"lyrics\"\n\n    # Construir la URL de la canción\n    url = f\"{base_url}/s/{artist}/{song_title}.html\"\n\n    # Hacer la solicitud GET al sitio web\n    response = requests.get(url)\n\n    if response.status_code == 200:\n        soup = BeautifulSoup(response.text, \"html.parser\")\n\n        # Buscar el div que contiene la letra\n        lyrics_div = soup.find(\"div\", class_=\"lcontent\")\n        if lyrics_div:\n            # Convertir líneas separadas por &lt;br&gt; en texto plano\n            lyrics = lyrics_div.get_text(separator=\" \", strip=True)\n            return lyrics\n\n    return None\n\n\n# Función para procesar un archivo CSV y obtener letras de canciones\ndef process_lyrics(\n    input_file: str,\n    output_file: str,\n    artist_name: str,\n    base_url: str = \"https://lyricsondemand.com\",\n) -&gt; None:\n    # Leer el archivo CSV\n    spotify_df = pd.read_csv(input_file, sep=\"\\t\")\n\n    # Lista para almacenar las letras\n    lyrics_data: List[Dict[str, str]] = []\n\n    # Iterar sobre las filas del DataFrame\n    for _, row in spotify_df.iterrows():\n        track_name = row[\"track_name\"]\n        # Limpiar el nombre de la canción (remover subtítulos entre paréntesis o guiones)\n        song_name = re.split(r\"[-\\(]\", track_name)[0].strip()\n\n        # Obtener la letra\n        lyrics = get_lyrics_from_lyricsondemand(artist_name, song_name, base_url)\n        if lyrics:\n            lyrics_data.append(\n                {\"artist_name\": artist_name, \"song_name\": song_name, \"lyrics\": lyrics}\n            )\n\n    # Convertir la lista de resultados a un DataFrame\n    lyrics_df = pd.DataFrame(lyrics_data)\n\n    # Guardar los resultados en un archivo CSV\n    lyrics_df.to_csv(output_file, sep=\"\\t\", index=False)\n\n\n\n\n\n# Asigno los valores a las constantes\nSPOTIFY_CLIENT_ID = os.getenv(\"SPOTIFY_CLIENT_ID\", \"\")\nSPOTIFY_CLIENT_SECRET = os.getenv(\"SPOTIFY_CLIENT_SECRET\", \"\")\nARTIST_NAME = \"Soda Stereo\"\nSONGS_FILE = \"../data/songs.tsv\"\nLYRICS_FILE = \"../data/lyrics.tsv\"\n\n# Verificar si el archivo songs ya existe\nif os.path.exists(SONGS_FILE):\n    pass\nelse:\n    spotify_client = initialize_spotify_client(SPOTIFY_CLIENT_ID, SPOTIFY_CLIENT_SECRET)\n    fetch_artist_data(spotify_client, ARTIST_NAME, SONGS_FILE)\n\n# Verificar si el archivo lyrics ya existe\nif os.path.exists(LYRICS_FILE):\n    pass\nelse:\n    process_lyrics(SONGS_FILE, LYRICS_FILE, ARTIST_NAME)"
  },
  {
    "objectID": "code/analysis.html#importar-librerias",
    "href": "code/analysis.html#importar-librerias",
    "title": "Scraping datos de canciones y letras + EDA",
    "section": "",
    "text": "import os\nfrom dotenv import load_dotenv\nimport subprocess\nimport pandas as pd\nimport time\nimport spotipy\nfrom spotipy.oauth2 import SpotifyClientCredentials\nimport requests\nfrom bs4 import BeautifulSoup\nimport unidecode\nimport re\nfrom typing import Optional"
  },
  {
    "objectID": "code/analysis.html#cargo-variales-de-archivo-.env",
    "href": "code/analysis.html#cargo-variales-de-archivo-.env",
    "title": "Scraping datos de canciones y letras + EDA",
    "section": "",
    "text": "# Cargar las variables de entorno desde el archivo .env\nresult = load_dotenv()"
  },
  {
    "objectID": "code/analysis.html#funciones-usadas-para-scraping-a-spotify",
    "href": "code/analysis.html#funciones-usadas-para-scraping-a-spotify",
    "title": "Scraping datos de canciones y letras + EDA",
    "section": "",
    "text": "# Función para inicializar el cliente de Spotify\ndef initialize_spotify_client(client_id: str, client_secret: str) -&gt; spotipy.Spotify:\n    auth_manager = SpotifyClientCredentials(\n        client_id=client_id, client_secret=client_secret\n    )\n    return spotipy.Spotify(auth_manager=auth_manager)\n\n\n# Función para obtener todos los álbumes de un artista\ndef get_albums(sp: spotipy.Spotify, artist_name: str) -&gt; list[dict[str, any]]:\n    results = sp.search(q=artist_name, type=\"artist\", limit=1)\n    artist_id = results[\"artists\"][\"items\"][0][\"id\"]\n\n    albums = []\n    results = sp.artist_albums(artist_id, limit=50, album_type=\"album\")\n    albums.extend(results[\"items\"])\n\n    while results[\"next\"]:\n        results = sp.next(results)\n        albums.extend(results[\"items\"])\n\n    return albums\n\n\n# Función para obtener las canciones de un álbum\ndef get_tracks_from_album(sp: spotipy.Spotify, album_id: str) -&gt; list[dict[str, any]]:\n    tracks = []\n    results = sp.album_tracks(album_id)\n    tracks.extend(results[\"items\"])\n\n    while results[\"next\"]:\n        results = sp.next(results)\n        tracks.extend(results[\"items\"])\n\n    return tracks\n\n\n# Función para obtener las características de audio de las canciones\ndef get_audio_features(\n    sp: spotipy.Spotify, track_ids: list[str]\n) -&gt; list[dict[str, any]]:\n    return sp.audio_features(track_ids)\n\n\n# Función principal para extraer información de un artista\ndef fetch_artist_data(\n    sp: spotipy.Spotify, artist_name: str, output_file: str, pause_time: float = 1.0\n) -&gt; list:\n    albums = get_albums(sp, artist_name)\n\n    song_data = []\n\n    for album in albums:\n        album_name = album[\"name\"]\n        album_id = album[\"id\"]\n        album_release_date = album[\"release_date\"]\n        album_type = album[\"album_type\"]\n\n        tracks = get_tracks_from_album(sp, album_id)\n\n        for track in tracks:\n            track_id = track[\"id\"]\n            track_name = track[\"name\"]\n            track_duration_ms = track[\"duration_ms\"]\n\n            audio_features = get_audio_features(sp, [track_id])[0]\n\n            song_data.append(\n                {\n                    \"album_name\": album_name,\n                    \"album_id\": album_id,\n                    \"album_release_date\": album_release_date,\n                    \"album_type\": album_type,\n                    \"track_name\": track_name,\n                    \"track_id\": track_id,\n                    \"track_duration_ms\": track_duration_ms,\n                    \"track_tempo\": audio_features[\"tempo\"],\n                    \"track_key\": audio_features[\"key\"],\n                    \"track_mode\": audio_features[\"mode\"],\n                    \"track_danceability\": audio_features[\"danceability\"],\n                    \"track_energy\": audio_features[\"energy\"],\n                    \"track_loudness\": audio_features[\"loudness\"],\n                    \"track_speechiness\": audio_features[\"speechiness\"],\n                    \"track_acousticness\": audio_features[\"acousticness\"],\n                    \"track_instrumentalness\": audio_features[\"instrumentalness\"],\n                    \"track_liveness\": audio_features[\"liveness\"],\n                    \"track_valence\": audio_features[\"valence\"],\n                    \"track_time_signature\": audio_features[\"time_signature\"],\n                }\n            )\n\n        # Pausar para evitar el límite de la API\n        time.sleep(pause_time)\n\n    # Guardar los datos en un archivo CSV\n    df = pd.DataFrame(song_data)\n    df.to_csv(output_file, sep=\"\\t\", index=False)"
  },
  {
    "objectID": "code/analysis.html#funciones-usadas-para-scraping-a-lyricsondemand",
    "href": "code/analysis.html#funciones-usadas-para-scraping-a-lyricsondemand",
    "title": "Scraping datos de canciones y letras + EDA",
    "section": "",
    "text": "# Función para obtener la letra de la canción de Lyrics On Demand\ndef get_lyrics_from_lyricsondemand(\n    artist: str, song_title: str, base_url: str = \"https://lyricsondemand.com\"\n) -&gt; Optional[str]:\n    # Normalizar nombres eliminando acentos y espacios\n    artist = unidecode.unidecode(artist.lower()).replace(\" \", \"\") + \"lyrics\"\n    song_title = unidecode.unidecode(song_title.lower()).replace(\" \", \"\") + \"lyrics\"\n\n    # Construir la URL de la canción\n    url = f\"{base_url}/s/{artist}/{song_title}.html\"\n\n    # Hacer la solicitud GET al sitio web\n    response = requests.get(url)\n\n    if response.status_code == 200:\n        soup = BeautifulSoup(response.text, \"html.parser\")\n\n        # Buscar el div que contiene la letra\n        lyrics_div = soup.find(\"div\", class_=\"lcontent\")\n        if lyrics_div:\n            # Convertir líneas separadas por &lt;br&gt; en texto plano\n            lyrics = lyrics_div.get_text(separator=\" \", strip=True)\n            return lyrics\n\n    return None\n\n\n# Función para procesar un archivo CSV y obtener letras de canciones\ndef process_lyrics(\n    input_file: str,\n    output_file: str,\n    artist_name: str,\n    base_url: str = \"https://lyricsondemand.com\",\n) -&gt; None:\n    # Leer el archivo CSV\n    spotify_df = pd.read_csv(input_file, sep=\"\\t\")\n\n    # Lista para almacenar las letras\n    lyrics_data: List[Dict[str, str]] = []\n\n    # Iterar sobre las filas del DataFrame\n    for _, row in spotify_df.iterrows():\n        track_name = row[\"track_name\"]\n        # Limpiar el nombre de la canción (remover subtítulos entre paréntesis o guiones)\n        song_name = re.split(r\"[-\\(]\", track_name)[0].strip()\n\n        # Obtener la letra\n        lyrics = get_lyrics_from_lyricsondemand(artist_name, song_name, base_url)\n        if lyrics:\n            lyrics_data.append(\n                {\"artist_name\": artist_name, \"song_name\": song_name, \"lyrics\": lyrics}\n            )\n\n    # Convertir la lista de resultados a un DataFrame\n    lyrics_df = pd.DataFrame(lyrics_data)\n\n    # Guardar los resultados en un archivo CSV\n    lyrics_df.to_csv(output_file, sep=\"\\t\", index=False)"
  },
  {
    "objectID": "code/analysis.html#definición-de-contantes-y-scraping",
    "href": "code/analysis.html#definición-de-contantes-y-scraping",
    "title": "Scraping datos de canciones y letras + EDA",
    "section": "",
    "text": "# Asigno los valores a las constantes\nSPOTIFY_CLIENT_ID = os.getenv(\"SPOTIFY_CLIENT_ID\", \"\")\nSPOTIFY_CLIENT_SECRET = os.getenv(\"SPOTIFY_CLIENT_SECRET\", \"\")\nARTIST_NAME = \"Soda Stereo\"\nSONGS_FILE = \"../data/songs.tsv\"\nLYRICS_FILE = \"../data/lyrics.tsv\"\n\n# Verificar si el archivo songs ya existe\nif os.path.exists(SONGS_FILE):\n    pass\nelse:\n    spotify_client = initialize_spotify_client(SPOTIFY_CLIENT_ID, SPOTIFY_CLIENT_SECRET)\n    fetch_artist_data(spotify_client, ARTIST_NAME, SONGS_FILE)\n\n# Verificar si el archivo lyrics ya existe\nif os.path.exists(LYRICS_FILE):\n    pass\nelse:\n    process_lyrics(SONGS_FILE, LYRICS_FILE, ARTIST_NAME)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "EDA de Soda Stereo",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites.\n\n\n\n\n\n\nNote\n\n\n\nPara ver info de instalación ver README.md"
  }
]